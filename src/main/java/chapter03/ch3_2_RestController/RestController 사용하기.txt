        MyBootAppApplication 클래스

스프링 스타터 프로젝트에는 자바 코드 파일 하나가 생성돼 있다.

    MyBootAppApplication 파일 확인

이 java 파일을 보자.

    SpringBootIntroductionJavaApplication.java

자세히 보면 일반적인 애플리케이션 클래스라는 것을 알 수 있다. 다른 클래스를 상속하는 것도 아닌
단수히 main 메소드가 하나 존재하는 간단한 코드다. 하지만 어노테이션 덕분에 조금 다르게 보인다.

    @SpringBootApplication 어노테이션

앞에 붙어 있는 @SpringBootApplication 어노테이션은 이 클래스가 스프링 부트의 애플리케이션 클래스라는 것을 나타낸다.
스프링 MVC에는 컴포넌트 스캔 기능이 있다. 설정 파일 등을 준비하지 않아도 어노테이션만 정의해두면 프로그램에서
사용하는 컴포넌트 전체를 자동으로 적용해서 사용할 수 있게 해주는 기능이다.
이 @SpringBootApplication을 정의해두면 다른 설정 파일이 없더라도 'MyBootAppApplication 클래스가
스프링 부트로 동작하는 프로그램' 이라는 것을 알 수 있다.

    SpringApplication 클래스와 run

main 메소드에서 실행하고 있는 것은 한 줄의 단순한 코드다. SpringApplication 클래스의 run 메소드를 실행하는 처리다.


    SpringApplication.run(MyBootAppApplication.class, args);


이 SpringApplication 클래스는 문자 그대로 스프링 부트의 애플리케이션 클래스다. 이 클래스에 스프링 부트 애플리케이션의
기본적인 기능이 탑재돼 있다. 여기서 실행하고 있는 run은 애플리케이션을 실행하기 위한 메소드다.
인수에는 실행할 클래스의 class 인스턴스와 매개변수로 전달할 데이터를 지정한다. 여기선 MyBootAppApplication 클래스를
그대로 실행할 클래스로 지정하고 있다.
이 MyBootAppApplication에는 @SpringBootApplication 어노테이션이 붙어있는 것 외에는 스프링 부트 애플리케이션임을
나타내는 것이 없다. 이런 클래스를 인수로 지정했을 때 스프링 부트는 기본 설정을 그대로 사용해서 애플리케이션을 실행한다.
본격적으로 스프링 부트를 사용하게 되면 다양한 설정 정보를 가진 클래스를 정의해서 SpringApplication.run의 인수로
지정할 수 있다. 하지만 지금은 '@SpringBootApplication 어노테이션을 정의하고 해당 클래스를 그대로 인수로 지정하면 된다.'
정도만 알고 있으면 충분하다.

        MVC 아키텍처에 대해

스프링 부트의 애플리케이션 클래스를 살펴봤다. 이 클래스가 존재하므로 프로젝트가 애플리케이션으로 실행되는 것이다.
하지만 실행만 되고 브라우저로 접속해보면 오류 화면이 뜬다. 애플리케이션은 준비됐지만 실제 표시할 페이지가 존재하지
않기 때문이다. 스프링 부트의 웹 애플리케이션은 'MVC 아키텍처' 라고 하는 개념을 기반으로 설계돼 있다. 이미 앞에서
다뤘지만 애플리케이션을 Model, View, Controller 라는 역할로 나누어 구축해가는 방식이다.

    Model(모델)   애플리케이션에서 사용할 데이터 보관
    View(뷰)      실제로 사용자가 보는 화면
    Controller    전체 처리를 제어

                    화면 표시
                    Controller
                  ↗             ↖
            데이터 가져오기     클라이언트
            ↙                       ↘
       View                           Model
                                        ↑
                                        ↓
                                     데이터베이스

    컨트롤러와 웹 페이지

이 중에서 가장 먼저 준비해야 하는 것이 컨트롤러로 애플리케이션 제어를 담당한다.
'애플리케이션 제어' 란 구체적으로는 '특정 주소에 접속했을 때 실행되는 처리' 를 의미한다.
스프링 부트에는 'URL 매핑' 기능이 탑재돼 있다. 특정 URL과 처리를 연결하는 기능이다. 이를 이용해서 어떤 URL에
접속하면 컨트롤러가 준비한 특정 메소드를 호출하도록 만들 수 있다.
즉, 컨트롤러를 만들면, 특정 URL에 접속했을 때 해당 URL과 연결된 메소드를 실행할 수 있게 되는 것이다(다른 말로
해당 URL에 접속할 수 있게 된다는 의미이다).

        컨트롤러 클래스 준비하기

컨트롤러 클래스를 작성해보자.
메이븐으로 생성한 프로젝트는 App.java 클래스가 있는 곳에 HeloController.java 라는 이름으로 파일을 만들면 된다.

        HeloController 작성하기

        HeloController.java

작성이 끝났다면 localhost:8080 에 접속해보자.

        RestController에 대해

여기서 작성한 HeloController 클래스도 특별한 클래스를 상속하거나 구현 하는 것이 아닌 아주 단순한 클래스다.
단지 애플리케이션 클래스와 마찬가지로 전용 어노테이션이 정의돼 있을 뿐이다.
이 클래스가 가지고 있는 것은 @RestController 라는 어노테이션이다. 이것은 앞장에서 그루비로 애플리케이션을
만들 때도 등장했다. 이 어노테이션이 클래스가 RestController 라는 것을 명시하고 있다.

    REST를 위한 컨트롤러

RestController란 'REST' 를 위한 전용 컨트롤러다.
앞 장에서 다룬 것처럼 REST는 REpresentative State Transfer 의 약자로 분산 시스템을 위한 아키텍쳐다.
네트워크를 경유해서 외부 서버에 접속하거나 필요한 정보를 불러오기 위한 구조라고 생각하면 된다.
그리고 이 REST 개념을 바탕으로 설계된 시스템을 'RESTFul' 이라고 표현한다.
이런 RESTFul 한 웹 서비스를 구축하기 위해 사용하는 것이 RestController인 것이다.
RestController 는 웹 애플리케이션의 일반적인 페이지(HTML 코드를 전송하는 페이지)에 비해 구조가 간단하다.
대부분은 HTML을 사용하지 않고 단순한 텍스트 정보를 전송하므로 HTML 기반의 웹 페이지보다 사용 방법도 간단하다.
먼저 이 RestController 클래스를 작성해서 REST 서비스를 만들어 보겠다. 이를 통해 컨트롤러의 기본적인 사용법을 익힐 수
있을 것이다.

                    →
        클라이언트       REST 웹 서비스
                    ←       ↓   ↑
                 데이터    각종 프로그램


        @RequestMapping 에 대해

이 클래스는 index 라는 메소드가 하나 존재하며 여기에도 @RequestMapping 어노테이션이 있다.
이것도 앞의 그루비 앱에서 등장했다. 리퀘스트 매핑에 관련된 것으로 다음과 같이 작성했었다.


    @RequestMapping(주소)


리퀘스트 매핑은 앞에서도 잠시 다뤘지만 서버의 URL과 특정 처리를 연동시키는(매핑시키는) 구조다.
메소드마다 '이것은 oo 라는 주소용 처리' 라고 연동해놓고, 서버로 요청이 온 경우 해당 주소에 할당돼 있는
메소드가 자동으로 실행되는 것이다.
이 리퀘스트 매핑을 설정하는 것이 @RequestMapping 어노테이션이다. 인수에 지정한 주소에 접속하면 해당 어노테이션이 있는
메소드가 자동으로 실행된다. 예에선 ("/")라는 인수를 지정해서 "/" 라는 주소에 접속하면 이 index 메소드가 실행되게
하고 있다.

    리퀘스트용 메소드에 대해

RestController 로 리퀘스트 매핑되는 메소드는 작성 방법이 정해져 있다. 정리하면 다음과 같은 형태가 된다.


    public String 메소드() {
        ... 처리 ...
        return 텍스트;
    }


메소드는 String 을 반환값으로 가지며 인수는 지정하지 않는다.(단, 인수를 사용하는 경우도 있다.)
return 으로 반환하는 텍스트가 클라이언트 측에 전송되는 텍스트다. 즉, 메소드 내에서 텍스트를 작성하고
그것을 return 하면 RESTFul 한 웹 서비스가 만들어지는 것이다.
이런 리퀘스트용(요청용) 메소드를 리퀘스트 핸들러라고 한다. 자바의 경우도 마찬가지로
리퀘스트 핸들러에는 @RequestMapping 어노테이션이 붙는다고 생각하면 된다.

        매개 변수 전달

좀 더 상호작용이 가능한 처리를 만들어보자. 간단한 값을 서버로 보내고 그것을 이용해서 어떤 결과를 반환하는 프로그램을
만들어보겠다. 이를 위해서는 리퀘스트 핸들러가 매개변수를 받을 수 있는 구조를 준비해야 한다.

    HeloController1.java

index 메소드에 있는 어노테이션과 메소드의 인수가 달라졌다. 이것을 실행한 후 주소 뒤에 숫자를 붙여 접속해보자.

    localhost:8080/100

접속하면 'total: 5050' 이라는 텍스트가 표시된다. '100' 이라는 매개변수를 받아서 1부터 100까지의 합을 계산하고
그 결과를 출력하고 있는 것이다. 주소 뒤에 있는 숫자(100) 를 다른 숫자로 변경해가며 확인해보자.

        매개변수와 @PathVariable

위 코드에서 '매개변수' 라는 기능을 사용하고 있다. 이것은 URL의 쿼리 스프링 부분에 지정한 값을 추출해서 사용하는
기능이다. 어노테이션을 보면 @RequestMapping("/{num}") 와 같이 돼있다. {num} 부분이 매개변수이다.
이것은 "/" 라는 주소 뒤에 있는 특정 값을 num 이라는 변수로 받으라는 의미이다.
index 메소드를 보면 다음과 같이 바꼈다는 것을 알 수 있다.


    public String index(@PathVariable int num) { ...


int num 이라는 인수가 추가됐다. 그 앞에 @PathVariable 이라는 어노테이션이 있다. 이것은 '이 인수가 매개변수에 의해
값을 전달받는다' 라는 의미다. 즉, "/{num}" 에 지정한 num이 인수 num에 전달되는 것이다.
localhost:8080/100 의 경우 100이 {num} 매개변수의 값이 된다. 이 값을 index 메소드 인수에 전달된다.
다음은 받은 변수를 계산해서 결과를 반환하기만 하면 된다.
그렇다면 localhost:8080/abc 의 경우엔 어떻게 될까? 오류가 발생한다.
abc라는 값이 정수로 인식되지 않기 때문이다.
localhost:8080/12.345 에 접속한다면 'total: 78' 이라고 출력된다.
인수로 지정한 데이터형으로 캐스트할 수 있다면 오류 없이 실행된다.

        객체를 JSON으로 출력하기

REST 서비스라는 것은 '텍스트를 출력' 하는 단순한 기능을 가지고 있지만 실운용 시스템에서 'Hello' 라는 텍스트만
출력하는 경우는 없다. 이런 서비스는 필요한 정보를 가져오기 위해 만드는 것이다.
자바에서 복잡한 정보를 다룰 때에는 클래스를 정의해서 해당 인스턴스의 형태로 정보를 주고받는 것이 일반적이다.
RestController 도 방식은 같다.
RestController 클래스는 String 을 반환값으로 지정하고 있지만 이것을 클래스로 변경할 수도 있다.
이 경우 반환하는 인스턴스의 내용을 JSON 형식으로 변환해서 텍스트로 출력하게 된다.
JSON은 'JavaScript Object Notion' 의 약자로 주로 자바스트립트의 객체를 텍스트로 주고받을 때 사용하는
데이터형이다. RestController 는 자바의 인스턴스를 이 JSON 형식의 텍스트로 변환해서 출력한다.
이것은 스프링 부트 측에서 자동으로 처리하므로 프로그래머가 직접 JSON 형식으로 변환할 필요가 없다.
단순히 인스턴스를 반환하기만 하면 되는 것이다.

    DataObject 출력하기

직접 해보자. 여기선 'DataObject' 라는 데이터를 관리하는 클래스를 만들겠다.
다음과 같이 작성해보자.

    HeloController2.java

localhost:8080/0 부터 4 까지의 번호 중 하나를 붙여서 접속해보자.
지정한 번호에 해당하는 데이터가 JSON 형식으로 출력된다.

    DataObject 클래스에 대해

위 코드에선 HeloController2 클래스 외에 DataObject 라는 클래스를 작성했다.
이 클래스에는 다음과 같은 필드들이 존재한다.


    private int id;
    private String name;
    private String value;


이 필드들은 각각 Getter/Setter 메소드를 가지고 있으며 외부에서 접근할 수 있다.
RestController 로 출력하는 클래스는 이런 접근자를 사용해서 필드의 값을 가져올 수 있게 작성해야 한다.

    리퀘스트 핸들러의 변경 내용 확인

그러면 HeloController 의 index 메소드가 어떻게 변경됐는지 보자. 다음과 같은 메소드가 사용되고 있다.


    @RequestMapping("/{id}")
    public DataObject index(@PathVariable int id) {
        return new DataObject(id, names[id], mails[id]);
    }


@RequestMapping 에선 "/{id}" 라는 형태로 URL 경로로부터 id 값을 전달하게 돼 있다.
이것은 @PathVariable int id 라는 인수 형태로 전달된다.
지금까지는 메소드의 반환 값이 String이었지만 여기선 'DataObject' 라는 것을 사용하고 있다.
return 에선 new DataObject 값을 그대로 반환하고 있다. DataObject를 String 으로 변환하는 처리가 존재하지 않는다.
이렇게 변환된 DataObject는 다음과 같은 형태의 텍스트로 변환돼서 출력된다.


    {"id":1,"name":"lee","value":"lee@flower"}


이것이 바로 JSON 형식의 텍스트다. 자바스크립트에선 이 텍스트를 간단하게 객체로 변환할 수 있다.
변환 후에는 객체에서 값을 꺼내서 자우롭게 처리하면 된다.